# 플레이 & 기능 검증 (Prototype & Verification) 가이드라인

## 1. 목적
게임 개발의 초기 단계에서 핵심 재미, 기술적 실현 가능성, 데이터 구조의 안정성을 빠르고 저비용으로 검증하기 위한 가이드입니다. 본격적인 프로덕션(Production) 진입 전 리스크를 최소화하는 것을 목표로 합니다.

## 2. 범위
- **포함**: 웹 기반 프로토타입(HTML/JS), LLM 활용 동작 검증, 버티컬 슬라이스 테스트 계획, 핵심 메카닉 단위 테스트
- **제외**: 상용 엔진(Unity/Unreal) 최적화, 최종 아트 리소스 제작, 마케팅/비즈니스 검증

## 3. 검증 목표

1.  **재미 검증**: 기획한 규칙이 실제로 플레이했을 때 재미있는가? (정성적 평가)
2.  **논리 검증**: 데이터 구조와 알고리즘이 모순 없이 작동하는가? (정량적/TDD)
3.  **기술 검증**: 핵심 메커니즘이 목표 플랫폼/환경에서 구현 가능한가?

## 4. 프로토타이핑 방법론

### 1. 웹/LLM 간소 구현

- 상용 엔진을 켜기 전, HTML/JS와 LLM을 활용해 핵심 로직을 텍스트/웹상에서 즉시 구현하고 테스트합니다.

- **도구**: Claude, ChatGPT, Gemini, Cursor, v0.dev, Replit
- **방식**:
  1. **프롬프트 입력**: 기획서(마크다운) 내용을 LLM에 입력하여 "이 규칙으로 동작하는 HTML 미니게임을 만들어줘"라고 요청.
  2. **데이터 연동(선택사항)**: json 을 연동하도록 구성해서 동작 확인
  3. **반복 개선**: 플레이 후 "공격 속도가 너무 느려", "UI가 복잡해" 등의 피드백을 주어 즉시 수정.

### 2 LLM 기반 버티컬 슬라이스

- 게임의 핵심 경험(Core Loop)을 처음부터 끝까지(메뉴 -> 플레이 -> 결과_경험할 수 있는 **완성도 높은 얇은 빌드**를 LLM을 통해 빠르게 제작하는 전략입니다.
- LLM의 컨텍스트 한계를 고려하여 **"흐름(Flow)"**과 **"모듈(Module)"**로 나누어 접근하는 것이 효과적입니다.

**예시 A:** 전체 스크린 플로우 검증 (Flow Slice)

- 단일 HTML 파일 내에서 버튼/UI 인터랙션만으로 게임의 전체 진입부터 종료까지의 흐름을 검증합니다. 실제 게임 플레이 로직은 생략하거나 단순화합니다.

- **목적**: UI 구조, 화면 전환 UX, 메뉴 진입 동선 검증
- **프롬프트 예시**:
    ```
    다음 레이싱 게임의 스크린 플로우를 단일 HTML로 구현해줘. 실제 레이싱 게임 플레이는 생략하고, 각 단계는 버튼 클릭으로 시뮬레이션해줘. 핵심은 전체 화면 전환 흐름을 검증하는 거야.
    1.  **타이틀** -> **로비**
    2.  **로비 구조**: [리그 참여], [차고/정비], [옵션] 메뉴 존재.
    3.  **리그 참여** -> [리그 리스트] -> [참여] -> [레이싱(생략/결과 바로가기)] -> [결과 화면] -> **로비** 복귀.
    4.  **차고** -> [차량 선택] -> [업그레이드] -> **로비** 복귀.
    5.  **옵션** -> [사운드 설정] -> **로비** 복귀.
    각 화면은 간단한 와이어프레임 박스 형태로 레이아웃만 잡아주고, 뒤로 가기 및 홈 이동 버튼을 배치해줘.
    ```

**예시 B**: 특정 기능 모듈 검증 (Module Slice)

- 복잡한 게임 전체를 만드는 대신, "강화", "전투", "상점" 등 특정 핵심 기능 하나만 떼어내어 깊이 있게 구현하고 조작감과 밸런스를 검증합니다.

- **목적**: 핵심 재미 요소(Core Fun), 조작감, 데이터 구조(JSON) 활용
- **프롬프트 예시 1**: 기능 모듈
    ```
    1280x768 해상도의 PC플랫폼 레이싱 게임의 '차량 업그레이드' 기능만 따로 떼어서 단일 HTML 프로토타입으로 만들어줘.

    **[핵심 요구사항: 데이터 기반 수정 기능]**
    1. 모든 수치(자금, 파츠 가격, 스탯)는 자바스크립트 내 `config` 객체로 분리해줘.
    2. 화면 우측 하단에 **[Config 입력창]**(TextArea)을 만들어서, JSON 텍스트를 붙여넣고 [적용] 버튼을 누르면 즉시 게임 내 밸런스가 업데이트되게 해줘. (CORS 문제 방지)
    3. 기본 데이터 포맷 예시:
       {
         "initialMoney": 10000,
         "parts": [
           { "id": "engine", "name": "Engine", "basePrice": 1000, "priceMult": 1.5, "stat": "power" }
         ]
       }

    **[기능 명세]**
    - 부품 구매 시 자금 차감 및 스탯 즉시 반영.
    - 다른 화면 불필요. 오직 업그레이드 패널 테스트에 집중.
    ```

**예시 C**: 핵심 메카닉 검증 (Core Mechanics)
- **목적**: 기본/핵심 동작을 점검
- **프롬프트 예시 1**: 핵심 메카닉 (Idle Game)

    ```
    다음 탭 아이들(Clicker) 게임의 핵심 메카닉을 검증하기 위한 단일 HTML 프로토타입을 만들어줘.
    1. **기본 동작**: 화면 중앙 버튼을 탭하면 +1 골드 획득.
    2. **업그레이드 1 (탭 강화)**: "탭 당 획득량 +1" 기능. 비용은 10 골드부터 시작하여 구매 시 1.5배씩 증가.
    3. **업그레이드 2 (자동 수익)**: "1초당 자동 획득 +1" 기능. 비용은 50 골드부터 시작하여 구매 시 1.5배씩 증가.
    4. **업그레이드 3 (고급 자동 수익)**: "1초당 자동 획득 +10" 기능. 비용은 500 골드부터 시작.
    5. **UI 레이아웃**: 상단에 [현재 골드], 중앙에 [탭 버튼], 하단에 [업그레이드 리스트] 배치.
    밸런스는 대략적이어도 좋으니, '탭 -> 골드 수집 -> 업그레이드 -> 더 빠른 수집'의 루프가 정상 작동하는지 확인하고 싶어.
    ```
- **프롬프트 예시 2**: 전투 메카닉 (Turn-based Card Battler)
    ```
    포커 규칙을 활용한 턴제 카드 배틀 게임의 전투 프로토타입을 단일 HTML로 만들어줘.

    **[게임 규칙]**
    1. **상태**: 플레이어 체력(50), 적 체력(100), 덱(트럼프 카드 52장).
    2. **카드 덱 규칙 (중요)**:
       - **유한한 덱**: 52장의 카드는 한번 사용되면 버려짐(Discards)으로 이동하여 다시 덱으로 돌아가지 않음.
       - **카드 카운팅**: 플레이어가 남은 카드를 예측할 수 있도록, 덱이 소진될 때까지 셔플하지 않음.
       - 덱 소진 시: "덱 고갈 패배" 처리하거나, 버린 카드를 다시 섞는 규칙 중 하나 선택 (여기서는 '덱 소진 시 패배'로 구현).
    3. **턴 진행**:
       - 턴 시작 시 카드 5장을 뽑음.
       - **리롤 기회**: 2회. 원하는 카드를 선택(Hold)하고, 나머지를 다시 뽑을 수 있음.
       - **공격**: 최종 핸드(족보)에 따라 데미지를 계산하여 적 공격.
         - 원페어(5), 투페어(10), 트리플(20), 풀하우스(30), 플러시(40), 스트레이트(50).
       - **적 턴**: 적은 매 턴 10의 고정 데미지로 플레이어 공격.
    4. **승리 조건**: 적 체력 0 이하. (패배: 플레이어 체력 0 이하 또는 덱 소진)
    5. **UI 요구사항**:
       - 현재 핸드 5장을 화면 중앙에 가로로 배치. 클릭하여 [Hold/Unhold] 토글 가능.
       - [리롤 버튼], [공격 버튼] 배치.
       - [남은 덱 매수] 표시 (예: 32/52).
       - 적과 플레이어의 HP 바 표시.
       - 전투 로그 텍스트 영역 표시.

    **[기술 제약]**
    - 별도 이미지 없이 CSS로 카드 모양(네모 박스, 숫자/문양 텍스트) 구현.
    - 각 핸드 족보 판별 로직(Algorithm)이 정확해야 함.
    ```
### 3. LLM 프롬프트 고도화 (Prompt Engineering)

- LLM으로 프롬프팅을 생성할 경우 주요 기능외의 세부사항 프롬프팅 작성 시간을 절약할 수 있습니다.

- **방식**:
  1. **초안 작성**: "레이싱 게임 업그레이드 화면 만들어줘" 정도로 간단히 작성.
  2. **프롬프트 강화 요청**:
      ```
      지금 내가 [레이싱 게임 업그레이드 화면]을 HTML로 즉시 구현하려 해.
      개발용 LLM에게 입력할 **구체적이고 명확한 지시 프롬프트**를 대신 작성해줘.
      해상도, 필수 기능, 예외 처리를 포함해서.
      ```
  3.  **검토 및 수정**: LLM이 작성한 프롬프트에서 불필요한 부분(과도한 그래픽 요구 등)을 삭제하고, '단일 HTML 파일', '와이어프레임 스타일' 등 제약 조건을 추가.
  4.  **최종 생성**: 수정된 프롬프트를 사용하여 프로토타입 생성 요청.

## 5. 단계별 검증 체크리스트 (Phase Checklist)

### Phase 3-1: 로직 및 아이디어 검증 (Pre-Alpha)
- [ ] **핵심 루프 작동**: "탐험 -> 전투 -> 보상 -> 성장"의 사이클이 끊김 없이 도는가?
- [ ] **엣지 케이스 처리**: 자원 부족, 인벤토리 가득 참, 시간 초과 등 예외 상황에서 게임이 멈추지 않는가?
- [ ] **확률/밸런스**: 시뮬레이션 결과가 기획 의도(승률, 자원 수급량)와 오차 범위(±10%) 내인가?

### Phase 3-2: 플레이 경험 검증 (Alpha Prototype)
- [ ] **조작감**: 입력 반응 속도(Input Lag)와 피드백이 만족스러운가?
- [ ] **학습 난이도**: 설명서 없이 플레이어가 첫 5분 안에 게임 규칙을 이해하는가? (튜토리얼 필요성 확인)
- [ ] **Fun Factor**: 테스터가 "한 판 더"를 외치거나 목표 달성을 위해 재도전하는가?

### Phase 3-3: 기술 및 데이터 구조 검증
- [ ] **데이터 호환**: 기획서의 데이터(JSON/YAML)가 실제 코드에서 별도 변환 없이 로드되는가?
- [ ] **성능 목표**: 목표로 하는 최소 사양에서 핵심 메카닉이 프레임 저하 없이 도는가?

## 6. 산출물 (Deliverables)

- **웹 데모 링크**: 클릭 한 번으로 플레이 가능한 HTML 파일 혹은 URL (Netlify, Vercel 등 배포)
- **플레이 로그**: 테스터들의 플레이 타임, 승률, 선택 분포 데이터
- **개선 제안서**: 프로토타입 결과에 기반한 기획 수정 제안 (규칙 변경, 수치 조정)

## 7. (추가) 파이썬을 활용한 기반 데이터 생성

- **목적**: 프로토타입 테스트용 대량 데이터를 수 작업 없이 빠르게 생성
- **프롬프트 예시**
  ```
  RPG 게임의 지역(Biome)별 몬스터 생태계를 생성하는 파이썬 스크립트를 만들어줘.

  **[입력 파일 1: biome_config.csv]**
  컬럼: biome_id, biome_name, level_min, level_max, dominant_element, rare_spawn_rate%, boss_count
  예시 데이터:
  - B01, 화산 지대, 10, 15, fire, 5, 1
  - B02, 깊은 숲, 8, 12, earth, 8, 1

  **[입력 파일 2: monster_templates.csv]**
  컬럼: template_id, base_name, element, type, base_hp, base_atk, rarity
  예시 데이터:
  - T001, 늑대, none, beast, 50, 5, common
  - T002, 용암 골렘, fire, demon, 200, 25, rare
  - T003, 드래곤, fire, dragon, 1000, 100, boss

  **[생성 규칙]**
  1. 각 바이옴마다 총 20마리 몬스터 생성 (보스 제외)
  2. dominant_element와 일치하는 몬스터가 70% 이상 구성되도록 템플릿 선택
  3. rare_spawn_rate%에 따라 희귀(rare) 등급 몬스터 포함
  4. 보스는 boss_count만큼 생성하되, 해당 바이옴의 level_max 레벨로 고정
  5. 일반 몬스터 레벨은 level_min ~ level_max 범위 내 균등 분포
  6. 스탯 스케일링: HP = base_hp × (1 + 레벨 × 0.15), ATK = base_atk × (1 + 레벨 × 0.12)

  **[출력 파일: biome_monsters.csv]**
  컬럼: monster_id, biome_id, name, level, element, type, hp, atk, rarity, is_boss
  예시: M_B01_001, B01, 화염 늑대 Lv12, 12, fire, beast, 140, 12, common, false

  **[추가 요구사항]**
  - 바이옴별 몬스터 구성 통계를 콘솔에 출력 (속성 분포, 희귀도 분포)
  - 보스가 일반 몬스터보다 평균 스탯이 3배 이상 높은지 검증 후 경고 출력
  ```
