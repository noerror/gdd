---
title: 데이터 스키마 & 코드블록 작성 가이드
description: 게임의 데이터 스키마와 코드블록을 체계적으로 설계하여 시스템 일관성과 확장성을 확보하는 데이터 아키텍처 가이드
---

# 데이터 스키마 & 코드블록 작성 가이드

## 1. 목적 (Purpose)
게임의 데이터 스키마와 코드블록을 체계적으로 정의하여 개발 효율성을 높이고 데이터 일관성을 보장하기 위한 가이드입니다.

## 2. 범위 (Scope)
- **포함**: 데이터 구조 정의, 스키마 설계, 코드 예시, 데이터 검증 규칙
- **제외**: 구체적인 코드 구현, 데이터베이스 최적화, 서버 아키텍처

## 3. 설계 목표 (Design Goals)

1. **명확한 구조 (Clear Structure)**: 데이터 구조가 직관적이고 이해하기 쉽습니다.
2. **확장성 (Scalability)**: 향후 기능 추가 시 쉽게 확장 가능합니다.
3. **일관성 (Consistency)**: 모든 데이터가 일관된 형식을 따릅니다.
4. **검증 가능성 (Validatable)**: 데이터 무결성을 검증할 수 있습니다.

## 4. GDD 문서 구조 (Structure)

### 4.1 데이터 스키마 (Data Schema)
- **엔티티 정의**: 캐릭터, 아이템, 퀘스트 등
- **속성 정의**: 각 엔티티의 필드와 타입

### 4.2 코드 예시 (Code Examples)
- **JSON/XML 예시**: 실제 데이터 구조
- **검증 규칙**: 필수 필드, 범위 제한

### 4.3 관계 & 참조 (Relationships & References)
- **외래 키**: 엔티티 간 관계
- **참조 무결성**: 데이터 일관성 유지

## 5. 관련 개념 (Key Concepts)

- **Schema**: 데이터 구조의 정의
- **Entity**: 데이터의 기본 단위 (캐릭터, 아이템 등)
- **Attribute**: 엔티티의 속성 (이름, 레벨 등)
- **Validation**: 데이터 무결성 검증

## 6. 품질 체크리스트 (Quality Checklist)

### 6.1 스키마 설계
- [ ] 모든 엔티티가 명확하게 정의되었는가?
- [ ] 속성의 타입과 제약이 명시되었는가?
- [ ] 스키마가 확장 가능한가?

### 6.2 코드 예시
- [ ] 실제 사용 가능한 코드 예시가 제공되는가?
- [ ] 검증 규칙이 명확한가?
- [ ] 엣지 케이스가 고려되었는가?

### 6.3 일관성
- [ ] 모든 데이터가 일관된 형식을 따르는가?
- [ ] 네이밍 규칙이 일관되는가?
- [ ] 참조 무결성이 유지되는가?

## 7. 예시 및 안티패턴 (Examples & Anti-Patterns)

**Case 1: 명확한 스키마**
- **좋은 예 (Good)**: "Character: {id: int, name: string, level: int (1-100), health: float (0-1000), skills: array<SkillID>}, 모든 필드가 타입과 제약 명시"
- **안티패턴 (Bad)**: "Character: {data: object}, 구조가 불명확하여 사용 어려움"

**Case 2: 검증 규칙**
- **좋은 예 (Good)**: "level은 1-100 범위, name은 필수 필드, skills는 최대 10개, 모든 규칙이 명시되어 검증 가능"
- **안티패턴 (Bad)**: "검증 규칙 없이 잘못된 데이터 입력 가능"

**Case 3: 확장성**
- **좋은 예 (Good)**: "기본 스키마 + 확장 필드(customData: object)로 향후 기능 추가 용이"
- **안티패턴 (Bad)**: "고정된 구조로 새로운 기능 추가 시 전체 스키마 변경 필요"

## 8. 핵심 인사이트 (Key Insights)

- **명확한 타입 정의**: 모든 필드의 타입과 제약을 명확히 정의하여 데이터 무결성을 보장하세요.
- **검증 규칙 명시**: 필수 필드, 범위 제한 등을 명시하여 잘못된 데이터 입력을 방지하세요.
- **확장성 고려**: 향후 기능 추가를 고려하여 확장 가능한 구조로 설계하세요.
- **일관된 네이밍**: 모든 엔티티와 속성에 일관된 네이밍 규칙을 적용하세요.

