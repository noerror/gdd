---
title: 데이터 스키마 & 코드블록 작성 가이드
description: 게임의 데이터 스키마와 코드블록을 체계적으로 설계하여 시스템 일관성과 확장성을 확보하는 데이터 아키텍처 가이드
---

# 데이터 스키마 & 코드블록 작성 가이드

## 1. 목적 (Purpose)
게임의 데이터 스키마와 코드블록을 체계적으로 정의하여 개발 효율성을 높이고 데이터 일관성을 보장하기 위한 가이드입니다.

## 2. 범위 (Scope)
- **포함**: 데이터 구조 정의, 스키마 설계, 코드 예시, 데이터 검증 규칙
- **제외**: 구체적인 코드 구현, 데이터베이스 최적화, 서버 아키텍처

## 3. 설계 목표 (Design Goals)

1. **명확한 구조 (Clear Structure)**: 데이터 구조가 직관적이고 이해하기 쉽습니다.
2. **확장성 (Scalability)**: 향후 기능 추가 시 쉽게 확장 가능합니다.
3. **일관성 (Consistency)**: 모든 데이터가 일관된 형식을 따릅니다.
4. **검증 가능성 (Validatable)**: 데이터 무결성을 검증할 수 있습니다.

## 4. GDD 문서 구조 (Structure)

### 4.1 데이터 스키마 (Data Schema)
- **엔티티 정의**: 캐릭터, 아이템, 퀘스트 등
- **속성 정의**: 각 엔티티의 필드와 타입

### 4.2 코드 예시 (Code Examples)
- **JSON/XML 예시**: 실제 데이터 구조
- **검증 규칙**: 필수 필드, 범위 제한

### 4.3 관계 & 참조 (Relationships & References)
- **외래 키**: 엔티티 간 관계
- **참조 무결성**: 데이터 일관성 유지

### 4.4 선택 및 심화 (Optional & Advanced)
- **스키마 마이그레이션**: 버전 업데이트 시 하위 호환성 유지 전략, 마이그레이션 스크립트 자동화, 롤백 계획 수립
- **데이터 검증 전략**: 스키마 레벨 검증(JSON Schema, XML DTD), 런타임 검증(Validator 클래스), 에디터 툴 실시간 검증
- **버전 관리**: 스키마 버전 명시(schemaVersion: "1.2.0"), 하위 호환 정책(최소 2개 버전 지원), 변경 이력 문서화
- **성능 최적화**: 직렬화/역직렬화 최적화(Protocol Buffers, MessagePack), 대용량 데이터 청크 분할, 지연 로딩 전략
- **실무 도구**: 스키마 검증 도구(JSON Schema Validator, Ajv), 코드 생성 도구(quicktype, json2csharp), 데이터 에디터(ScriptableObject, Odin Inspector)

## 5. 관련 개념 (Key Concepts)

### 5.1 스키마 설계
- **Schema**: 데이터 구조의 정의 및 규칙
- **Entity**: 데이터의 기본 단위 (캐릭터, 아이템, 퀘스트 등)
- **Attribute**: 엔티티의 속성 (이름, 레벨, 타입 등)

### 5.2 데이터 무결성
- **Validation**: 데이터 무결성 검증 (타입 체크, 범위 검증, 필수 필드 확인)
- **Referential Integrity**: 참조 무결성 (외래 키 유효성, 순환 참조 방지)
- **Data Normalization**: 데이터 정규화 (중복 제거, 일관성 유지)

### 5.3 직렬화 & 포맷
- **Serialization**: 데이터를 저장 가능한 형식으로 변환 (JSON, XML, Binary)
- **Data Format**: 데이터 포맷 선택 (JSON: 가독성, Protobuf: 성능, YAML: 설정 파일)
- **Schema Migration**: 스키마 변경 시 기존 데이터 마이그레이션 전략

## 6. 품질 체크리스트 (Quality Checklist)

### 6.1 스키마 설계
- [ ] 모든 엔티티가 명확하게 정의되었는가?
- [ ] 속성의 타입과 제약이 명시되었는가?
- [ ] 스키마가 확장 가능한가?

### 6.2 코드 예시
- [ ] 실제 사용 가능한 코드 예시가 제공되는가?
- [ ] 검증 규칙이 명확한가?
- [ ] 엣지 케이스가 고려되었는가?

### 6.3 일관성
- [ ] 모든 데이터가 일관된 형식을 따르는가?
- [ ] 네이밍 규칙이 일관되는가?
- [ ] 참조 무결성이 유지되는가?

## 7. 예시 및 안티패턴 (Examples & Anti-Patterns)

**Case 1: 명확한 스키마**
- **좋은 예 (Good)**: "Character: {id: int, name: string, level: int (1-100), health: float (0-1000), skills: array<SkillID>}, 모든 필드가 타입과 제약 명시"
- **안티패턴 (Bad)**: "Character: {data: object}, 구조가 불명확하여 사용 어려움"

**Case 2: 검증 규칙**
- **좋은 예 (Good)**: "level은 1-100 범위, name은 필수 필드, skills는 최대 10개, 모든 규칙이 명시되어 검증 가능"
- **안티패턴 (Bad)**: "검증 규칙 없이 잘못된 데이터 입력 가능"

**Case 3: 확장성**
- **좋은 예 (Good)**: "기본 스키마 + 확장 필드(customData: object)로 향후 기능 추가 용이"
- **안티패턴 (Bad)**: "고정된 구조로 새로운 기능 추가 시 전체 스키마 변경 필요"

**Case 4: 스키마 버전 관리 (Destiny 2)**
- **좋은 예 (Good)**: "아이템 스키마에 schemaVersion: 3, 버전별 마이그레이션 로직 분리, 2년 이상 된 데이터도 자동 변환으로 하위 호환 유지"
- **안티패턴 (Bad)**: "스키마 변경 시 기존 데이터 초기화, 플레이어 진행 손실"

**Case 5: 타입 안전성 (Path of Exile)**
- **좋은 예 (Good)**: "아이템 스킬 스키마를 강타입으로 정의, TypeScript 활용으로 컴파일 타임 검증, 1500개 이상 스킬 데이터 오류율 0.1% 미만 유지"
- **안티패턴 (Bad)**: "약타입 사용으로 런타임 오류 빈번 발생, 데이터 입력 실수 방지 불가"

**Case 6: 데이터 에디터 통합 (Unity ScriptableObject - Hollow Knight)**
- **좋은 예 (Good)**: "적 AI 스키마를 ScriptableObject로 구현, Unity Editor에서 직접 편집, 디자이너가 코드 없이 150종 이상 적 데이터 생성"
- **안티패턴 (Bad)**: "JSON 수동 편집으로 오타 빈발, 디자이너가 개발자 의존"

**Case 7: 직렬화 최적화 (Genshin Impact)**
- **좋은 예 (Good)**: "대용량 오픈월드 데이터를 Protocol Buffers로 직렬화, JSON 대비 70% 용량 감소, 로딩 시간 50% 단축"
- **안티패턴 (Bad)**: "모든 데이터를 JSON으로 저장하여 모바일 로딩 시간 과다"

## 8. 핵심 인사이트 (Key Insights)

- **타입 안전성 우선 (Path of Exile)**: 강타입 언어(TypeScript, C#)로 스키마 정의, 컴파일 타임 검증으로 데이터 오류 사전 방지, 대규모 데이터에서 오류율 0.1% 미만 달성
- **스키마 버전 관리 필수 (Destiny 2)**: schemaVersion 필드로 명시적 버전 관리, 최소 2개 버전 하위 호환 유지, 마이그레이션 로직 자동화로 플레이어 데이터 손실 방지
- **에디터 통합으로 생산성 향상 (Hollow Knight)**: ScriptableObject, Odin Inspector 등 활용, 디자이너가 코드 없이 데이터 편집, 개발자 의존성 80% 감소
- **직렬화 포맷 전략적 선택 (Genshin Impact)**: 개발 중 JSON(가독성), 빌드 시 Protobuf(성능/용량), 설정 파일 YAML(간결성)로 용도별 분리
- **검증 3단계 전략**: 1) 스키마 레벨(JSON Schema), 2) 에디터 실시간 검증, 3) 런타임 Assertion으로 다층 방어

