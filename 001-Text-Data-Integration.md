---
title: 텍스트 기반 기획/데이터 연동 환경
description: 마크다운을 단일 진실 소스로 활용해 기획서와 게임 데이터를 통합하고, 코드 블록 임베딩·추출·자동화 워크플로우를 정리한 가이드
---

# 텍스트 기반 기획/데이터 연동 환경

## 1. 키 컨셉

- 마크다운 기반 단일 진실 소스(SSoT) / 기획서가 곧 실행 데이터
- 텍스트 기반 버전 관리 / Git 연동 / 협업 최적화
- LLM,RAG 자동 참조 / 프로그래머 직접 개발환경 참조
- 코드 블럭 데이터 임베딩 / 파싱 자동화 / 기획↔구현 일치

## 2. 마크다운 기반 문서 시스템

### 1. 개발 환경
1. **Obsidian**: 충실한 마크다운 기반 에디팅 환경에 직관적 아웃라이너, 경로 무시 파일 링크 지원 및 역참조 확인 등 편의 기능. 그래프, 캘릭터, 캔버스, DB검색, 칸반(Trello)등 다양한 플러그인 지원
2. **Typora**: 실시간 미리보기와 경량 편집 환경
3. **VSCode,Cursor**: 개발 환경과 LLM 연동을 묶어 코드, 기획 동시 편집을 지원

### 2.장점
4. **Git,SVN**: 텍스트 기반이라 머지가 용이하고, 브랜치, 이력 관리도 용이(history 변경 확인, blame 으로 라인별 작성자와 작성일 확인)
5. **LLM 연동 자동화**: RAG 기반 문서 임베딩으로 기획 컨텍스트를 호출하고, 코드 생성, 일관성 검증, 자동 문서화를 한 번에 처리
6. **협업 동기화**: 프로그래머가 프로그래밍 개발 환경에서 동일한 마크다운 소스를 즉시 열람하여 실시간으로 기획 변경 사항을 공유합니다.

### 3.개발 지원

1. **확장 기능 개발 활용**: LLM을 이용해서 마크 다운 기반으로한 도구들 개발 활용 필요 (무드 이미지 뷰어, 인터랙티브 차트, 상태 다이어그램 등 시각, 데이터 확장 모듈, 각종 게임 수치 시뮬레이터)

## 3. 데이터 임베딩 시스템

- **목적**: 기획서와 실제 게임 데이터를 하나의 소스로 통합 / 문서-코드 불일치 제거

### 1. 핵심 작업

**코드 블럭 임베딩:**
- 마크다운 코드 블럭 내 데이터 작성 / 표준 문법 : 언어명 + 콜론 + 파일명/ID
- 예시1 : ```yaml:character_001
- 예시2 : ```json:skill_fireball

**데이터 포맷:**
- **JSON** : 파싱 빠름 / 프로그래밍 표준 / 직렬화 연동 / 중첩 구조 명확
- **YAML** : **주석 가능** / JSON호환 / 구조가 단순해서 직접 입력 유리 / 권장 1순위
- **CSV/TSV** : 대량 테이블 데이터 / 구조가 단순 / 엑셀 호환 / 스프레드시트 변환
- **XML** : 레거시 호환 / 복잡한 구조 / 스키마 검증
- **기타** : Lisp,TOML 등 텍스트 기반 모두 가능

**활용 데이터:**
- 캐릭터 스탯 : HP,MP,공격력,방어력,스킬 트리
- 스킬/아이템 정보 : 효과,쿨타임,레벨,드롭률,조합 레시피
- 다이얼로그 스크립트 : 대사,선택지,분기,메타데이터(감정,의도)
- 이벤트/퀘스트 : 트리거,조건,보상,플래그
- 밸런싱 테이블 : 경험치 곡선,경제 밸런스,드롭 테이블
- 예시 (CSV 포맷)
    ````  
    ```csv:item_weapons
    item_id,name,type,rarity,attack,durability,level_req,special_effect,drop_rate
    wep_001,녹슨 검,sword,common,10,50,1,,0.5
    wep_002,강철 검,sword,uncommon,25,100,5,,0.3
    wep_003,불꽃의 검,sword,rare,40,150,10,fire_damage_+10,0.05
    wep_004,드래곤 슬레이어,sword,legendary,100,300,20,dragon_slayer,0.001
    ```
    ````

**다중 블럭 / 파일 번들링:**
- 하나의 .md 파일에 여러 데이터 블럭 / 각각 고유 ID
- 여러 파일 패킹 가능 : 관련 데이터를 하나의 문서에 묶어 관리 / 필요시 개별 추출

    ````
    - 전사 기본 설정 (YAML)
    > 캐릭터 기본 스탯과 장비 슬롯 정의입니다.
    ```yaml:char_warrior_base.yaml
    id: char_001
    class: warrior
    base_stats:
      hp: 120
      str: 15
    equip_slots: [weapon, armor]
    # 기획 노트: 초반 생존력을 위해 HP 비중을 높게 설정함
    ```    
    - 전사 초기 드롭 테이블 (JSON)
    > 몬스터 처치 시 획득 가능한 아이템 목록입니다.
    ```json:loot_table_warrior_start.json
    {
      "table_id": "loot_warrior_lv1",
      "items": [
        {"id": "potion_hp_small", "rate": 0.5},
        {"id": "old_coin", "rate": 0.3},
        {"id": "training_sword", "rate": 0.05}
      ],
      "note": "초반 물약 수급을 원활하게 하여 난이도 조절"
    }
    ```
    ````

- 예시 : characters.md 안에 전사,마법사,도적 데이터 블럭 각각 존재 / 빌드 시 개별 파일로 분리 또는 번들로 통합
- **응용**:같은 이름의 데이터 누적해서 사용 가능

    ````
    - 방어구 데이터는 기계 번역,밸런싱 툴이 참조하므로, 기본형과 희귀형을 별도 블럭으로 분리해 변경 이력을 추적합니다.
    - 각 블럭은 `item_armors` ID를 공유하되 `set_bonus` 여부로 구분해 파이프라인에서 조건부 로딩을 수행합니다.
    ```csv:item_armors
    item_id,name,class,rarity,defense,weight,resist,level_req,set_bonus
    arm_010,가죽 숄더,light,common,8,4,poison+5,1,
    arm_021,미스릴 흉갑,medium,rare,32,12,ice+10,12,guardian_core
    arm_033,스펙트럴 망토,light,epic,24,2,shadow+15,18,phantom_walk
    ```
    ### 레이드 보상 전용 세트
    - 레이드 보상 전용 세트는 독립 블럭으로 분리해 이벤트 일정에 맞춰 배포하고, 일반 장비와 충돌 없이 실험 밸런싱을 진행합니다.
    > 메타 정보: `set_twilight` 태그를 키로 삼아 레이드 전용 룰셋을 로딩하며, 적용 여부는 빌드 옵션 플래그로 제어합니다.
    ```csv:item_armors
    arm_050,황혼의 수호자,heavy,legendary,60,25,shadow+20,25,set_twilight
    ```
    ````

### 2. 추출 예제

- 코드 블럭을 추출해서 파일로 단순하게 저장
- 중복된 파일인 경우 뒤에 append 하도록

**추출 예제**
```python
# extract_code_blocks.py
import re
import sys
from pathlib import Path

def extract_and_save(md_file, output_dir="output"):
    text = Path(md_file).read_text(encoding='utf-8')
    processed = set()
    
    for match in re.finditer(r'```(\w+):([^\n]+)\n(.*?)```', text, re.DOTALL):
        _, filename, code = match.groups()
        path = Path(output_dir) / filename.strip()
        path.parent.mkdir(parents=True, exist_ok=True)
        
        mode = 'a' if path in processed else 'w'
        with open(path, mode, encoding='utf-8') as f: f.write(code + "\n")
        processed.add(path)
        print(f"{'+' if mode == 'a' else 'N'} {path}")

if __name__ == "__main__":
    md_file = sys.argv[1] if len(sys.argv) > 1 else "design-doc.md"
    output_dir = sys.argv[2] if len(sys.argv) > 2 else "output"
    extract_and_save(md_file, output_dir)
```
**사용법**
```
python extract_code_blocks.py design-doc.md data/extracted
```

### 3. 워크플로우

- 기획서 작성 -> 코드 추출 -> 게임 데이터로 임포트 (혹은 추출 상태로 사용)

## 4. 활용 아이디어 예시

- 기획 의도,변경 이유 주석 / LLM 컨텍스트로 활용
- 다국어 번역 시 원문,번역,검수 상태 함께 관리
- QA 체크리스트 / 밸런스 검증 로그

### 1. 데이터 최적화

- yaml, json 처럼 바로 직렬화할 수 있는 데이터 외에도, 데이터 형식을 변경해서 활용할 수 있도록 합니다.

**다이얼로그 데이터 제안**
- **실제 데이터 포함**: 기획서 내에 실 다이얼로그 데이터를 포함해 작성 단계를 최적화합니다.
- **맥락 메타데이터 활용**: 대사 전후의 기획 의도(음성 디렉션, 맥락, 뉘앙스)를 메타데이터로 사용합니다.
  - **번역 품질 향상**: 전문 번역 요청 혹은 LLM 자동 번역 시 맥락 정보를 제공해 오역을 방지합니다.
  - **자동 병합**: 언어 테이블 구조로 자동 파싱되어, 엔진 임포트 시 기존 시스템과 즉시 병합됩니다.
- **예제**

    ````
    ### 퀘스트 도입부: 촌장의 의뢰
    - 상황: 플레이어가 튜토리얼을 마치고 처음 마을에 진입한 직후
    - 등장인물: 촌장(Elder), 주인공(Hero)
    - 연출 의도: 평화롭던 마을에 위기감이 감도는 분위기 조성. 촌장은 주인공을 구세주처럼 반김.    
    ```dialog:quest_start_001
    @scene: village_entrance
    @bgm: mysterious_forest.mp3
    @trigger: level >= 1
    
    :elder (face: worried)
    "자네가 소문의 그 용병인가? 마을 밖 숲이 심상치 않아."
    (en) "Are you the mercenary from the rumors? The forest outside is unsettling."
    (jp) "君が噂の傭兵か？村の外の森の様子がおかしいんだ。"
    @voice: elder_001.ogg
    ;note: 걱정스러운 노인의 목소리. 약간 떨리게 연기해주세요.
    
    :hero (face: confident)
    "무슨 일이시죠? 제가 해결해 드리겠습니다."
    (en) "What's wrong? I'll handle it."
    (jp) "何事ですか？私が解決しましょう。"
    @voice: young_hero_001.ogg
    ;note: 자신감 넘치는 젊은이.
    
    :elder (face: relief)
    "고맙네! 숲 입구의 늑대들을 좀 쫓아내 주게나."
    (en) "Thank you! Please drive away the wolves at the entrance."
    (jp) "ありがたい！森の入り口の狼たちを追い払ってくれ。"
    ```
    ````

### 2. LLM 연동해서 데이터 생성

- **LLM 도구 활용**: Cursor, Codex CLI 환경에서 기획서(Context)를 기반으로 데이터 생성, 검증, 분석을 자동화합니다.
- **MCP(Model Context Protocol) 연동**: LLM이 프로젝트 내 관련 문서를 스스로 탐색(Retrieval)하고 분석하여 작업 실행력을 극대화합니다.
- **활용 예시**:
  > game-pitch.md의 '핵심 기둥' 항목을 참조하여 전투 시스템 규칙 초안을 작성해줘.

  > 캐릭터 설정 텍스트를 분석해서, 그 성격과 역할에 어울리는 스탯 초기값을 YAML 데이터로 생성해줘.

**자동 참조 데이터 판단**
- LLM이 기존 기획서에서 관련 데이터 자동 탐색 / RAG로 컨텍스트 구성
- 예시 : "화염 마법사 직업 추가" → LLM이 기존 전사,도적 데이터 참조 → 일관된 구조로 생성
- 참조 우선순위 : 같은 카테고리 → 비슷한 레벨 → 동일 시스템
    ```
    프롬프트: "새로운 '암살자' 직업 추가"
    
    LLM 프로세스:
    1. 기존 직업 데이터 검색 (전사,도적,마법사)
    2. 도적과 유사성 파악 → 참조 데이터로 선정
    3. 차별화 포인트 추출 (기획서의 "암살자는 단일 대상 고화력" 메모 발견)
    4. 규칙 준수하며 스탯,스킬,성장 곡선 생성
    5. 기존 직업과 밸런스 비교표 자동 생성
    ```

**지침 파일 기반 작업**
- 데이터 규칙 파일을 지침(instruction)에 포함 / 스키마,네이밍,밸런스 기준 명시
- LLM이 지침 참조하여 일관된 데이터 생성 / 수동 작성 대비 시간 90% 단축
- 예시 : "skill_template.md 규칙에 따라 얼음 속성 스킬 5개 생성"

**데이터 지침 역분석:**
- 기존 데이터 패턴 분석 → 암묵적 규칙 추출 → 지침 문서 자동 보강
- 예시1 : 스킬 50개 분석 → "쿨타임 = 데미지 × 0.2초" 규칙 발견 → 지침에 추가
- 예시2
    ````
    프롬프트: "현재 모든 무기 데이터를 분석하고 암묵적 규칙을 찾아 schema-rules.md에 추가"
    
    LLM 분석:
    - 50개 무기 데이터 스캔
    - 패턴 발견:
    * 공격력 = 10 × (레벨 요구 ÷ 2)
    * 희귀도 높을수록 특수 효과 개수 증가 (common:0, rare:1, legendary:2+)
    * 양손 무기는 공격력 1.5배, 공격 속도 0.7배
    
    생성된 규칙:
    ```yaml
    weapon_balance_rules:
    attack_calculation: "10 × (level_requirement ÷ 2)"
    special_effects:
        common: 0
        uncommon: 0-1
        rare: 1
        legendary: 2+
    two_handed_multiplier:
        attack: 1.5
        speed: 0.7
    ```
    
    업데이트: schema-rules.md에 자동 추가 제안
    ````

**컨텍스트 관리 & 최적화**
- **압축 컨텍스트 제공**: LLM의 맥락 처리 한계를 보완하기 위해 태그와 메타 정보로 요약된 전용 컨텍스트 문서를 별도 생성하여 제공합니다. (예: `summary_skills.md`)
- **품질 평가 기준(Rubrics)**: 생성된 데이터의 품질을 일관되게 유지하기 위해 명확한 평가 체크리스트를 함께 제공합니다.
  > 참조: [DR Tulu 논문](https://arxiv.org/abs/2511.19399) (소형 모델에 Rubrics 최적화로 딥리서치 벤치마크에서 최상위급 모델 Gemini 3 pro+Search 상회)

**코드 없는 대규모 데이터 작업 (No-Code & Plan)**
- **Agent 모드 활용**: Cursor, Codex CLI 등의 에이전트 기능을 통해 코딩 없이 자연어로 복잡한 데이터 작업을 지시합니다.
- **실행 계획 수립**: 대량 작업 시 단계별 플랜을 먼저 수립하게 하여 실행 안정성을 높입니다.
  > 예시: "100개 스킬 리스트 분석 -> 분류 체계 수립 -> 각 스킬 파일 생성 및 설명 작성 순서로 실행해줘"

**아이디어**
- **데이터 일관성 검증**: 전체 데이터 스캔 후 규칙 위반 항목 리포트
  > 예시: "스킬 15개 중 3개가 쿨타임 공식 위반" → 자동 수정 제안
- **밸런스 분석 & 제안**: 데이터 간 파워 레벨 비교 및 이상치 탐지
  > 예시: "화염구 스킬이 DPS 기준 동급 대비 150% 성능" → 너프 제안
- **자동 문서화**: 코드 블럭 데이터 읽고 설명 문서 자동 생성
  > 예시: 스킬 50개 데이터 → "스킬 가이드북" 문서 자동 작성 (분류, 설명, 팁)
- **템플릿 기반 배리에이션**: 기본 템플릿 + 파라미터 조합으로 수십 개 배리에이션 자동 생성
  > 예시: "기본 검" 템플릿 × 속성 조합(화염, 얼음, 독) × 등급(일반, 희귀, 전설) = 9종 자동 생성
- **데이터 관계 그래프**: 의존성, 선후 관계, 조합 분석 후 그래프 다이어그램 생성
  > 예시: "스킬 A는 스킬 B 선행 필요" → Mermaid 다이어그램 출력
- **QA 체크리스트 자동 생성**: 기획 내용과 데이터 기반으로 테스트 케이스 생성
  > 예시: "초반부 퀘스트 데이터와 조건을 정리해서 QA 체크리스트를 작성해줘"

### 3. 도구 개발 및 연동

**LLM을 활용한 도구 개발 (LLM for Dev Tools)**
- **웹 기반 도구 제작 (Vibe Coding)**: FastAPI 등을 활용해 기획 데이터의 시각화 및 수정이 가능한 웹 툴을 신속하게 개발합니다.
  - **크로스 레퍼런스 검색**: "이 아이템을 드롭하는 몬스터는?" / "이 스킬을 사용하는 캐릭터는?" 같은 관계 역추적- 
  - **엑셀 <-> 마크다운 변환기**: 기존 엑셀 기획서를 마크다운 코드 블럭으로 자동 변환 / 역변환으로 비개발자 협업 지원
  - **실시간 데이터 품질 모니터링**: 규칙 위반·누락 필드·중복 ID·밸런스 이상치를 웹 대시보드로 시각화
  - **파워 레벨 히트맵**: 레벨·등급별 아이템/스킬 파워를 색상 그래프로 표시 / 밸런스 붕괴 지점 한눈에 파악
  - **로그 분석기**: 플레이테스트 로그 업로드 → 실제 데이터와 기획 의도 비교 → 괴리 지점 리포트
  - **다이얼로그 시각화**: 다이얼로그의 대사와 선택지를 시각화하여 플레이어의 경험을 예측하고 밸런스를 검증합니다.
- **더미 데이터 생성**: 기획서 내용을 기반으로 테스트에 필요한 대량의 더미 데이터를 즉시 생성합니다.
  > 예시: "1~10레벨 몬스터의 드롭 테이블 50종을 생성하는 스크립트를 짜줘. 단, 장비(10%), 소비(40%), 잡동사니(50%) 카테고리 비율을 유지하고, 레벨에 따라 보상 가치가 완만하게 상승하도록 확률을 조정해."
- **수치 시뮬레이터**: 기획 의도만 설명하면 컨텍스트와 데이터를 기반으로 Python 기반 시뮬레이션 코드를 자동 생성합니다.
  - **자동 정보 수집**: 별도의 상세 명세 없이 "현재 구현된 데미지 공식 기준으로 시뮬레이션해줘"라고 요청하면, LLM이 스스로 코드를 분석해 로직을 추출합니다.
  - **데이터 검증**: 실제 데이터와 로직을 기반으로 시뮬레이션을 수행해, 밸런스 붕괴나 엣지 케이스를 사전에 차단합니다.
  - **코드베이스 참조의 강력함**: 저장소의 실제 게임 코드(전투 공식, 아이템 구조 등)를 직접 참조하게 하면, 기획 의도와 실제 구현이 일치하는 **실전급 고정밀 시뮬레이션**이 가능합니다.

**LLM을 사용하는 도구 개발 (Tools using LLM)**
- **AI 어시스턴트 시스템**: 로컬 LLM을 내장하여 24시간 기획 내용을 검토하고 개선안을 제안하는 전용 봇을 운용합니다.
- **다국어 워크플로우 자동화**: 다이얼로그 데이터의 빈 영역을 감지하여 기획 맥락(Context)에 맞춰 자동으로 번역하고 업데이트합니다.
- **Tip: 로컬 LLM 활용 팁 (MoA)** : 동일한 작업을 반복 수행하고 상호 평가하게 하면 개선된 결과를 도출합니다. (참조: [MoA 논문](https://arxiv.org/abs/2406.04692) - 오픈소스 모델 조합으로 코딩 벤치 AlpacaEval 에서 2024년 당시 최상위 모델 GPT-4o 성능 상회)